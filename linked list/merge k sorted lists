âœ… Approach 1: Min-Heap (Priority Queue)

Push the head of each non-empty list into a min-heap.

Pop the smallest node from the heap and add it to the merged list.

If the popped node has a next, push next into the heap.

Repeat until the heap is empty.

This ensures the merged list is sorted.

from heapq import heappush, heappop

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:
        dummy = ListNode(-1)
        tail = dummy
        heap = []

        # Step 1: Initialize heap with the head of each list
        for i, node in enumerate(lists):
            if node:
                heappush(heap, (node.val, i, node))

        # Step 2: Merge lists using the heap
        while heap:
            val, i, node = heappop(heap)
            tail.next = node
            tail = tail.next
            if node.next:
                heappush(heap, (node.next.val, i, node.next))

        return dummy.next






| Metric | Complexity | Explanation                                                         |
| ------ | ---------- | ------------------------------------------------------------------- |
| Time   | O(N log k) | N = total nodes, k = number of lists. Heap operations take O(log k) |
| Space  | O(k)       | Heap stores at most k nodes                                         |
